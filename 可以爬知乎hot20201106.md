可以爬知乎hot

```go
package main

import (
   "fmt"
   "io/ioutil"
   "net/http"
   "regexp"
)

func main(){

   resp,err:=http.Get("https://tophub.today/n/mproPpoq6O")
   //异常时进行panic
   if err!=nil{
      panic(err)
   }
   //延时关闭
   defer resp.Body.Close()

   //状态码错误时输出错误码
   //if resp.StatusCode!=http.StatusOK{
   // fmt.Printf("Error ststus code:%d",resp.StatusCode)
   //}
   //注释部分都是懒得下载第三方包 这一部分是调用后面的函数来实现对编码方式的检查
   //bodyReader:=bufio.NewReader(resp.Body)
   //e:=determinEncoding(bodyReader)
   ////这里实现编码转换
   //utf8Reader:=transform.NewReader(bodyReader,e.NewDecoder())
   //借助io.reader获取流的信息
   //result,err:=ioutil.ReadAll(utf8Reader)假如发生编码转换则需要下一行改参数名
   result,err:=ioutil.ReadAll(resp.Body)
   if err!=nil{
      panic(err)
   }
   //不打印全部所以注释掉下一行（改用正则检索）
      //fmt.Printf("%s",result)
   //用正则检索打印
   paraseContent(result)

   //href<我理解为链接 有这个标签就会有子层的目录 比方说http://www.shouxindehai.cn/index.php/cs/>
   //在这里可以在终端搜索这个目录发现可以找到 说明是可以爬到的
   //该段代码适用于utf-8的编码的网址
   //gbk会乱码的
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
)

func main(){

	resp,err:=http.Get("https://tophub.today/n/mproPpoq6O")
	//异常时进行panic
	if err!=nil{
		panic(err)
	}
	//延时关闭
	defer resp.Body.Close()

	//状态码错误时输出错误码
	//if resp.StatusCode!=http.StatusOK{
	// fmt.Printf("Error ststus code:%d",resp.StatusCode)
	//}
	//注释部分都是懒得下载第三方包 这一部分是调用后面的函数来实现对编码方式的检查
	//bodyReader:=bufio.NewReader(resp.Body)
	//e:=determinEncoding(bodyReader)
	////这里实现编码转换
	//utf8Reader:=transform.NewReader(bodyReader,e.NewDecoder())
	//借助io.reader获取流的信息
	//result,err:=ioutil.ReadAll(utf8Reader)假如发生编码转换则需要下一行改参数名
	result,err:=ioutil.ReadAll(resp.Body)
	if err!=nil{
		panic(err)
	}

	//fmt.Printf("%s",result)
	Writetxt(result)

	//href<我理解为链接 有这个标签就会有子层的目录 比方说http://www.shouxindehai.cn/index.php/cs/>
	//在这里可以在终端搜索这个目录发现可以找到 说明是可以爬到的
	//该段代码适用于utf-8的编码的网址
	//gbk会乱码的
	//写到这里发现知乎有反扒（可能和cookie有关系）

}


func Writetxt(content []byte){
	f, err := os.Create("知乎热搜.txt")
	if err != nil {
		fmt.Println(err)
		return
	}
	l, err := f.Write(content)
	if err != nil {
		fmt.Println(err)
		f.Close()
		return
	}
	fmt.Println(l, "bytes written successfully")
	err = f.Close()
	if err != nil {
		fmt.Println(err)
		return
	}
}

func Sendmail(){

}
















//这个用到main函数里头（正则表达式）
//func paraseContent(content []byte){
//	//([^"]+)
//	//<td class="al"><a href="略" target="_blank" rel="nofollow" itemid="20551837">如何看待</a></td>
//	//                                        <td>2074 万热度</td>
//	re:=regexp.MustCompile(`<td class="([^"]+)"><a href="([^"]+)" target="([^"]+)" rel="([^"]+)" itemid="([^"]+)">([^"]+)</a></td>`)
//	re_:=regexp.MustCompile(`<td>([^"]+)</td>`)
//	match:=re.FindAllSubmatch(content,-1)
//	match_:=re_.FindAllSubmatch(content,-1)
//	for _,m:=range match{
//		fmt.Printf("%s \n",m[6])
//	}
//	for _,m:=range match_{
//		fmt.Printf("热度：%s \n",m[1])
//	}
//}



//这还得用第三方库 还得翻墙 那真麻烦 那就算了吧 代码留在这里好了
//设计一个检查编码方式的函数（知乎用的是utf-8所以用不上貌似 先注释掉备份吧）
// func derterminEncoding(r*bufio.Reader)encoding.Encoding{
//    bytes,err:=r.Peek(n:1024)
//    if err1=nil{
//       log.Printf("fetch error:%v",err)
//       return unicode.UTF8
//    }
//
//    e,_,_:=charset.DetermineEncoding(bytes,contentType:"")
//    return e
// }
```